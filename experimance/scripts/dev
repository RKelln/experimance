#!/bin/bash

# Development script for Experimance
# Usage: ./scripts/dev [service_name|all]
# 
# Automatically detects remote vs local development:
# - Remote (SSH): Display service runs on installation monitors via desktop session
# - Local: Display service uses normal X11/Wayland environment
# 
# Examples:
#   ./scripts/dev display          # Start display service 
#   ./scripts/dev health core      # Start multiple services
#   ./scripts/dev all              # Start all services

# Color definitions
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Get script directory and repo root
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )"
REPO_DIR="$(dirname "$SCRIPT_DIR")"

# Simple warn function
warn() {
    echo -e "${YELLOW}WARNING: $1${NC}"
}

# Function to kill existing experimance services
cleanup_existing_services() {
    echo -e "${BLUE}Cleaning up any existing experimance services...${NC}"
    
    # Use the available services (stored at script start)
    local service_suffixes=("${AVAILABLE_SERVICES[@]}")
    
    local killed_count=0
    
    # Send SIGINT to processes that match our service patterns (graceful shutdown)
    for suffix in "${service_suffixes[@]}"; do
        # Pattern: any process running python with module ending in our suffix
        # This catches: python -m experimance_core, python -m sohkepayin_core, etc.
        if pgrep -f "experimance.*python.*-m.*${suffix}(\$| )" >/dev/null 2>&1; then
            echo -e "  ${YELLOW}Sending SIGINT to existing ${suffix} processes...${NC}"
            pkill -INT -f "experimance.*python.*-m.*${suffix}(\$| )" 2>/dev/null || true
            killed_count=$((killed_count + 1))
        fi
        
        # Also check for uv run patterns (with or without -m)
        if pgrep -f "uv run.*${suffix}(\$| )" >/dev/null 2>&1; then
            echo -e "  ${YELLOW}Sending SIGINT to existing uv run ${suffix} processes...${NC}" 
            pkill -INT -f "uv run.*${suffix}(\$| )" 2>/dev/null || true
            killed_count=$((killed_count + 1))
        fi
        
        # Check for our .venv python processes running our specific services
        # This is more targeted than killing all .venv processes
        local venv_path="$REPO_DIR/.venv/bin/python"
        if pgrep -f "$venv_path.*-m.*${suffix}(\$| )" >/dev/null 2>&1; then
            echo -e "  ${YELLOW}Sending SIGINT to .venv ${suffix} processes...${NC}"
            pkill -INT -f "$venv_path.*-m.*${suffix}(\$| )" 2>/dev/null || true
            killed_count=$((killed_count + 1))
        fi
    done
    
    # Give processes time to terminate gracefully
    if [ $killed_count -gt 0 ]; then
        echo -e "  ${BLUE}Waiting for processes to terminate gracefully...${NC}"
        
        # Wait up to 15 seconds for graceful shutdown (health notifications + cleanup)
        local wait_count=0
        local max_wait=15
        while [ $wait_count -lt $max_wait ]; do
            local still_running=false
            for suffix in "${service_suffixes[@]}"; do
                if pgrep -f "python.*-m.*${suffix}(\$| )" >/dev/null 2>&1 || \
                   pgrep -f "uv run.*${suffix}(\$| )" >/dev/null 2>&1 || \
                   pgrep -f "$REPO_DIR/.venv/bin/python.*-m.*${suffix}(\$| )" >/dev/null 2>&1; then
                    still_running=true
                    break
                fi
            done
            
            if [ "$still_running" = false ]; then
                echo -e "  ${GREEN}All processes terminated gracefully.${NC}"
                break
            fi
            
            sleep 1
            wait_count=$((wait_count + 1))
            if [ $((wait_count % 5)) -eq 0 ]; then
                echo -e "  ${YELLOW}Still waiting for graceful shutdown... (${wait_count}s)${NC}"
            fi
        done
        
        # Force kill any remaining processes
        for suffix in "${service_suffixes[@]}"; do
            if pgrep -f "python.*-m.*${suffix}(\$| )" >/dev/null 2>&1; then
                echo -e "  ${RED}Force killing stubborn ${suffix} processes...${NC}"
                pkill -9 -f "python.*-m.*${suffix}(\$| )" 2>/dev/null || true
            fi
            if pgrep -f "uv run.*${suffix}(\$| )" >/dev/null 2>&1; then
                echo -e "  ${RED}Force killing stubborn uv run ${suffix} processes...${NC}"
                pkill -9 -f "uv run.*${suffix}(\$| )" 2>/dev/null || true
            fi
            # Force kill specific .venv service processes
            local venv_path="$REPO_DIR/.venv/bin/python"
            if pgrep -f "$venv_path.*-m.*${suffix}(\$| )" >/dev/null 2>&1; then
                echo -e "  ${RED}Force killing stubborn .venv ${suffix} processes...${NC}"
                pkill -9 -f "$venv_path.*-m.*${suffix}(\$| )" 2>/dev/null || true
            fi
        done
        
        echo -e "  ${GREEN}Cleanup completed.${NC}"
    else
        echo -e "  ${GREEN}No existing services found.${NC}"
    fi
    echo ""
}

# Export functions so they're available in subshells
export -f warn

# Disable real notifications
export NOTIFICATIONS_DRY_RUN=true

# Map service names to module paths
get_module_name() {
    local service="$1"
    case "$service" in
        "core")
            echo "experimance_core"
            ;;
        "display")
            echo "experimance_display"
            ;;
        "agent")
            echo "experimance_agent"
            ;;
        "audio")
            echo "experimance_audio"
            ;;
        "health")
            echo "experimance_health"
            ;;
        "image_server")
            echo "image_server"
            ;;
        "transition")
            echo "experimance_transition"
            ;;
        *)
            # Try to find the service directory and guess module name
            if [ -d "$REPO_DIR/services/$service" ]; then
                echo "experimance_${service}"
            else
                echo "$service"  # Fallback to service name as-is
            fi
            ;;
    esac
}

# Export the function so it's available in subshells
export -f get_module_name

# Function to detect if we're in a remote session
is_remote_session() {
    # Check if we're connected via SSH
    [ -n "$SSH_CLIENT" ] || [ -n "$SSH_TTY" ] || [ -n "$SSH_CONNECTION" ] || \
    # Check for VS Code remote session
    [ -n "$VSCODE_IPC_HOOK_CLI" ] || [ -n "$REMOTE_CONTAINERS" ] || [ -n "$CODESPACES" ] || \
    [ "$TERM_PROGRAM" = "vscode" ] || \
    # Check for VS Code server process (another indicator)
    pgrep -f "vscode-server" >/dev/null 2>&1 || \
    # Additional SSH indicators
    [ -n "$SSH_AUTH_SOCK" ] && [[ "$SSH_AUTH_SOCK" == *"vscode"* ]]
}

# Function to setup display environment for display service
setup_display_environment() {
    # If we already have a working display, use it
    if [ -n "$DISPLAY" ] && command -v xrandr >/dev/null 2>&1 && xrandr >/dev/null 2>&1; then
        echo -e "${GREEN}âœ“ Using existing display environment: $DISPLAY${NC}"
        return 0
    fi
    
    # For remote sessions, try to find the desktop session
    if is_remote_session; then
        echo -e "${BLUE}Remote session detected - setting up display for installation monitors...${NC}"
        
        # Find active desktop session
        DESKTOP_SESSION=$(loginctl list-sessions --no-legend | grep 'seat0.*active' | awk '{print $1}' | head -1)
        if [ -n "$DESKTOP_SESSION" ]; then
            echo -e "${GREEN}Found active desktop session: $DESKTOP_SESSION${NC}"
            
            # Get display environment from GNOME process
            GNOME_PID=$(pgrep -u "$USER" gnome-shell | head -1)
            if [ -n "$GNOME_PID" ] && [ -r "/proc/$GNOME_PID/environ" ]; then
                DESKTOP_DISPLAY=$(tr '\0' '\n' < "/proc/$GNOME_PID/environ" | grep '^DISPLAY=' | cut -d= -f2)
                DESKTOP_XDG_SESSION_TYPE=$(tr '\0' '\n' < "/proc/$GNOME_PID/environ" | grep '^XDG_SESSION_TYPE=' | cut -d= -f2)
                DESKTOP_XAUTHORITY=$(tr '\0' '\n' < "/proc/$GNOME_PID/environ" | grep '^XAUTHORITY=' | cut -d= -f2)
                
                # For Wayland sessions, check for Xwayland
                if [ "$DESKTOP_XDG_SESSION_TYPE" = "wayland" ] && pgrep -f "Xwayland.*:0" >/dev/null 2>&1; then
                    DESKTOP_DISPLAY=":0"
                    XWAYLAND_AUTH=$(find /run/user/$(id -u)/ -name ".mutter-Xwaylandauth.*" 2>/dev/null | head -1)
                    [ -n "$XWAYLAND_AUTH" ] && DESKTOP_XAUTHORITY="$XWAYLAND_AUTH"
                    echo -e "${GREEN}Found Xwayland on :0${NC}"
                fi
                
                # Export the desktop environment
                [ -n "$DESKTOP_DISPLAY" ] && export DISPLAY="$DESKTOP_DISPLAY"
                [ -n "$DESKTOP_XAUTHORITY" ] && export XAUTHORITY="$DESKTOP_XAUTHORITY"
            fi
        fi
    else
        # Local development - try to use existing session or force headless
        echo -e "${BLUE}Local development detected${NC}"
        
        # Try current user's display session
        if [ -z "$DISPLAY" ]; then
            # Check if we have an active X session
            if pgrep -u "$USER" -x Xorg >/dev/null 2>&1 || pgrep -u "$USER" -x gnome-shell >/dev/null 2>&1; then
                # Try to get display from existing session
                GNOME_PID=$(pgrep -u "$USER" gnome-shell | head -1)
                if [ -n "$GNOME_PID" ] && [ -r "/proc/$GNOME_PID/environ" ]; then
                    DESKTOP_DISPLAY=$(tr '\0' '\n' < "/proc/$GNOME_PID/environ" | grep '^DISPLAY=' | cut -d= -f2)
                    DESKTOP_XAUTHORITY=$(tr '\0' '\n' < "/proc/$GNOME_PID/environ" | grep '^XAUTHORITY=' | cut -d= -f2)
                    
                    # Check for Xwayland
                    if pgrep -f "Xwayland.*:0" >/dev/null 2>&1; then
                        DESKTOP_DISPLAY=":0"
                        XWAYLAND_AUTH=$(find /run/user/$(id -u)/ -name ".mutter-Xwaylandauth.*" 2>/dev/null | head -1)
                        [ -n "$XWAYLAND_AUTH" ] && DESKTOP_XAUTHORITY="$XWAYLAND_AUTH"
                        echo -e "${GREEN}Found Xwayland for local session${NC}"
                    fi
                    
                    [ -n "$DESKTOP_DISPLAY" ] && export DISPLAY="$DESKTOP_DISPLAY"
                    [ -n "$DESKTOP_XAUTHORITY" ] && export XAUTHORITY="$DESKTOP_XAUTHORITY"
                else
                    echo -e "${YELLOW}Local GUI session detected but can't access environment - forcing headless mode${NC}"
                    export EXPERIMANCE_DISPLAY_HEADLESS=true
                fi
            else
                echo -e "${YELLOW}No GUI session detected - forcing headless mode${NC}"
                export EXPERIMANCE_DISPLAY_HEADLESS=true
            fi
        fi
    fi
    
    # Final fallback - if still no display, force headless
    if [ -z "$DISPLAY" ] && [ "$EXPERIMANCE_DISPLAY_HEADLESS" != "true" ]; then
        echo -e "${YELLOW}No display environment found - forcing headless mode${NC}"
        export EXPERIMANCE_DISPLAY_HEADLESS=true
    fi
}

# Function to run services with proper display access
run_with_display() {
    local service="$1"
    local module_name="$2"
    
    # For display service, ensure proper display environment
    if [ "$service" = "display" ]; then
        setup_display_environment
        
        # Test display connection
        if [ -n "$DISPLAY" ] && command -v xrandr >/dev/null 2>&1; then
            if xrandr --listmonitors >/dev/null 2>&1; then
                echo -e "${GREEN}âœ“ Display connection successful${NC}"
                monitor_count=$(xrandr --listmonitors | grep -c "Monitor")
                echo -e "${BLUE}Found $monitor_count monitor(s)${NC}"
            else
                echo -e "${YELLOW}Display connection available but no monitors detected${NC}"
            fi
        fi
        
        # Use systemd-run for remote sessions to ensure proper session context
        if is_remote_session && command -v systemd-run >/dev/null 2>&1; then
            echo -e "${GREEN}Using systemd-run for desktop session context...${NC}"
            systemd-run --user --scope --slice=app.slice \
                --setenv=DISPLAY="$DISPLAY" \
                --setenv=XAUTHORITY="$XAUTHORITY" \
                --setenv=EXPERIMANCE_ENV=development \
                --working-directory="$REPO_DIR" \
                uv run -m "$module_name"
            return
        fi
    fi
    
    # Run the service normally
    uv run -m "$module_name"
}

# Export the function
export -f run_with_display

# Get available services dynamically using the same script as deploy.sh
get_available_services() {
    local project="${1:-experimance}"
    local services_script="$REPO_DIR/infra/scripts/get_project_services.py"
    
    if [[ -f "$services_script" ]]; then
        cd "$REPO_DIR"
        if command -v uv >/dev/null 2>&1; then
            # Get services and strip the @project suffix, convert to service names
            uv run python "$services_script" "$project" 2>/dev/null | sed 's/@.*//' | sed 's/experimance-//' | sed 's/image-server/image_server/'
        else
            # Fallback to scanning services directory
            if [ -d "$REPO_DIR/services" ]; then
                for service_dir in "$REPO_DIR/services"/*; do
                    if [ -d "$service_dir" ]; then
                        basename "$service_dir"
                    fi
                done
            else
                echo "core"
                echo "display"
                echo "agent"
                echo "audio"
                echo "health"
                echo "image_server"
            fi
        fi
    else
        # Fallback to scanning services directory
        if [ -d "$REPO_DIR/services" ]; then
            for service_dir in "$REPO_DIR/services"/*; do
                if [ -d "$service_dir" ]; then
                    basename "$service_dir"
                fi
            done
        else
            echo "core"
            echo "display"
            echo "agent"
            echo "audio"
            echo "health"
            echo "image_server"
        fi
    fi
}

# Get available services
readarray -t AVAILABLE_SERVICES < <(get_available_services "${PROJECT:-experimance}")

# Parse command line arguments
REQUESTED_SERVICES=()

# Parse arguments - just service names now
REQUESTED_SERVICES=("$@")

# Check if service names are provided
if [ ${#REQUESTED_SERVICES[@]} -eq 0 ]; then
    echo -e "${RED}Error: Service name(s) required${NC}"
    echo -e "Usage: ${YELLOW}./scripts/dev <service_name(s)|all>${NC}"
    echo ""
    echo "Available services:"
    
    for service in "${AVAILABLE_SERVICES[@]}"; do
        echo "  - $service"
    done
    echo "  - all                          # Start all services"
    echo ""
    echo "Examples:"
    echo "  ./scripts/dev display          # Start display service on monitors"
    echo "  ./scripts/dev health core      # Start multiple services"
    echo "  ./scripts/dev all              # Start all services"
    exit 1
fi

# Parse all command line arguments as services
SERVICES_TO_START=()
if [[ "${REQUESTED_SERVICES[0]}" == "all" ]]; then
    if [[ ${#REQUESTED_SERVICES[@]} -gt 1 ]]; then
        echo -e "${RED}Error: Cannot specify other services when using 'all'${NC}"
        exit 1
    fi
    # Use all available services
    SERVICES_TO_START=("${AVAILABLE_SERVICES[@]}")
else
    # Validate that all requested services exist
    SERVICES_TO_START=()
    for service in "${REQUESTED_SERVICES[@]}"; do
        if [[ " ${AVAILABLE_SERVICES[@]} " =~ " ${service} " ]]; then
            SERVICES_TO_START+=("$service")
        else
            echo -e "${RED}Error: Service '${service}' not found${NC}"
            echo "Available services:"
            for available_service in "${AVAILABLE_SERVICES[@]}"; do
                echo "  - $available_service"
            done
            exit 1
        fi
    done
fi

# Cleanup any existing services before starting new ones
cleanup_existing_services

# Determine startup mode based on number of services
if [[ ${#SERVICES_TO_START[@]} -eq 1 ]]; then
    # Single service mode - run in foreground
    SERVICE="${SERVICES_TO_START[0]}"
    SERVICE_PATH="$REPO_DIR/services/$SERVICE"
    
    # Check if service directory exists
    if [ ! -d "$SERVICE_PATH" ]; then
        echo -e "${RED}Error: Service directory '${SERVICE_PATH}' not found${NC}"
        exit 1
    fi
    
    MODULE_NAME=$(get_module_name "$SERVICE")
    
    echo -e "${BLUE}Starting ${SERVICE} service in development mode...${NC}"
    echo -e "${BLUE}Service path: ${SERVICE_PATH}${NC}"
    echo -e "${BLUE}Module name: ${MODULE_NAME}${NC}"

    # Change to repo directory for uv to work properly
    cd "$REPO_DIR"

    # Set development environment
    export EXPERIMANCE_ENV=development

    # Start service using uv run with display handling
    echo -e "${GREEN}Running: uv run -m ${MODULE_NAME}${NC}"
    run_with_display "$SERVICE" "$MODULE_NAME"
    
else
    # Multiple services mode - run in background with logging
    service_count=${#SERVICES_TO_START[@]}
    if [[ "${REQUESTED_SERVICES[0]}" == "all" ]]; then
        echo -e "${BLUE}Starting all services for development...${NC}"
    else
        echo -e "${BLUE}Starting $service_count services for development...${NC}"
        echo -e "${BLUE}Services: ${SERVICES_TO_START[*]}${NC}"
    fi
    echo -e "${YELLOW}This will start services in the background with logging.${NC}"
    echo -e "${YELLOW}Press Ctrl+C in this terminal to stop all services.${NC}"
    echo ""
    
    # Array to store background process IDs
    declare -a PIDS=()
    
    # Function to cleanup on exit
    cleanup() {
        echo -e "\n${YELLOW}Stopping all services...${NC}"
        
        # Use the available services (stored at script start)
        local service_suffixes=("${AVAILABLE_SERVICES[@]}")
        
        local killed_count=0
        
        # Send SIGINT to processes that match our service patterns (graceful shutdown)
        for suffix in "${service_suffixes[@]}"; do
            # Target the Python process directly (not the uv run wrapper)
            # Pattern: python process running in experimance directory with our module
            if pgrep -f "experimance.*python.*-m.*${suffix}(\$| )" >/dev/null 2>&1; then
                echo -e "  ${YELLOW}Sending SIGINT to ${suffix} Python process...${NC}"
                pkill -INT -f "experimance.*python.*-m.*${suffix}(\$| )" 2>/dev/null || true
                killed_count=$((killed_count + 1))
            fi
        done
        
        if [ $killed_count -gt 0 ]; then
            echo -e "${BLUE}Waiting for graceful shutdown...${NC}"
            
            # Wait up to 15 seconds for graceful shutdown
            local wait_count=0
            local max_wait=15
            while [ $wait_count -lt $max_wait ]; do
                local still_running=false
                for suffix in "${service_suffixes[@]}"; do
                    # Check if Python processes are still running
                    if pgrep -f "experimance.*python.*-m.*${suffix}(\$| )" >/dev/null 2>&1; then
                        still_running=true
                        break
                    fi
                done
                
                if [ "$still_running" = false ]; then
                    echo -e "${GREEN}All services terminated gracefully.${NC}"
                    break
                fi
                
                sleep 1
                wait_count=$((wait_count + 1))
                if [ $((wait_count % 5)) -eq 0 ]; then
                    echo -e "${YELLOW}Still waiting for graceful shutdown... (${wait_count}s)${NC}"
                fi
            done
            
            # Force kill any remaining processes after timeout
            for suffix in "${service_suffixes[@]}"; do
                if pgrep -f "experimance.*python.*-m.*${suffix}(\$| )" >/dev/null 2>&1; then
                    echo -e "${RED}Force killing stubborn ${suffix} Python process...${NC}"
                    pkill -9 -f "experimance.*python.*-m.*${suffix}(\$| )" 2>/dev/null || true
                fi
            done
        else
            echo -e "${GREEN}No services found to stop.${NC}"
        fi
        
        wait
        echo -e "${GREEN}All services stopped.${NC}"
        exit 0
    }
    
    # Set up signal handlers
    trap cleanup SIGINT SIGTERM
    
    # Create log directory (with fallback)
    if ! mkdir -p "$REPO_DIR/logs/dev" 2>/dev/null; then
        # Fallback to current directory if we can't create in repo
        mkdir -p "./dev-logs"
        LOG_DIR="./dev-logs"
        warn "Could not create logs/dev, using ./dev-logs instead"
    else
        LOG_DIR="$REPO_DIR/logs/dev"
    fi
    
    # Change to repo directory
    cd "$REPO_DIR"
    export EXPERIMANCE_ENV=development
    
    # Start each requested service in background with logging
    for service in "${SERVICES_TO_START[@]}"; do
        echo -e "${BLUE}Starting $service service...${NC}"
        
        # Get module name for this service
        module_name=$(get_module_name "$service")
        
        # Start service in background, showing output in terminal AND logging to file
        echo "$(date): Starting $service ($module_name)" >> "$LOG_DIR/$service.log"
        # Use a simpler approach that preserves signal handling but shows output
        uv run -m "$module_name" 2>&1 | while IFS= read -r line; do
            echo "[$service] $line"
            echo "$line" >> "$LOG_DIR/$service.log"
        done &
        
        PIDS+=($!)
        echo -e "${GREEN}Started $service (PID: $!) - logs: $LOG_DIR/$service.log${NC}"
        sleep 2  # Small delay between service starts to avoid port conflicts
    done
    
    echo ""
    echo -e "${GREEN}All services started!${NC}"
    echo -e "${BLUE}Logs are being written to: $LOG_DIR/SERVICE_NAME.log${NC}"
    echo -e "${BLUE}To view logs in another terminal:${NC}"
    for service in "${SERVICES_TO_START[@]}"; do
        echo -e "  ${GREEN}tail -f $LOG_DIR/$service.log${NC}"
    done
    echo -e "${YELLOW}Press Ctrl+C to stop all services.${NC}"
    echo ""
    
    # Wait for all background processes
    wait
fi
